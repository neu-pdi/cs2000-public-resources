---
sidebar_position: 27
day_number: 27
title: Day 27 - Scoping & equality
---

## Skills: [10](</skills/#(10)>)

## Pre-reading: [13.1](%7B%7BDCIC_DOMAIN%7D%7D/mutating-variables.html), [12.2](%7B%7BDCIC_DOMAIN%7D%7D/unified-equality.html)

## Intro (15 mins)

- Today we explore how variable assignment, mutability, and scoping work in Pyret and Python, and how equality works in both languages.
- **Pyret: Mutable vs Immutable**
  ```pyret
  x = 10
  # Can't do this, x is immutable
  # x := 20   # Error!

  var y = 5
  y := y + 2  # y is now 7

  # Can't re-declare a name in the same scope:
  # y = 20    # Error!
  ```
- **Python: Assignment and Scoping**
  ```python
  x = 10
  x = 20  # x is now 20 -- all variables are mutable

  y = 5
  y = y + 2  # y is now 7

  # Scoping example:
  y = 20
  def f():
      y = 30  # This is a new local y, does not affect global y
      return y
  print(f())  # prints 30
  print(y)    # prints 20

  # Using global keyword:
  z = 100
  def g():
      global z # Now `z` within function is same as `z` at top level
      z = 200
  g()
  print(z)    # prints 200
  ```
- **Equality:**
  - In Python, `==` checks value equality (i.e., if you wrote down values on paper, they look the same), `is` checks object identity (i.e., there is one one place in memory they are both stored, so if one is changed, both change).
    ```python
    [1, 2, 3] == [1, 2, 3]  # True -- same values
    [1, 2, 3] is [1, 2, 3]  # False -- not the same memory
    x = [1, 2, 3]
    y = x
    x is y  # True, same memory
    ```
  - This is different from Pyret, where `is` shows up only in _tests_, where it checks that **values are always the same** (so they are either immutable and equal as values, or if mutable, point to same memory). This is the _same_ as what `==` does in Pyret. Pyret has other forms of equality (`equal-now`, `identical`), but we don't cover them in this class.

## Class Exercises (40 mins)

- Given this Python code, predict what will happen and explain why:

  ```python
  y = 100
  def outer():
      y = 200
      def inner():
          y = y + 50
          return y
      return inner()
  print(outer())
  ```

  Now fix the code so that `inner()` updates the `y` from `outer()`.

- Given this Pyret code, predict what will happen and explain why:

  ```pyret
  x = 10
  fun f() block:
    x := x + 5
    x
  end
  f()
  ```

  Now fix the code so that `f()` updates `x` correctly.

- Given this Python code, predict what will print and explain why:

  ```python
  x = 10
  def foo():
      x = x + 1
      return x
  print(foo())
  ```

  Now fix the above code so that it increments the global `x`.

- Given this Pyret code, predict what will happen and explain why:

  ```pyret
  var a = 10
  fun inc() block:
    a := a + 1
    a
  end
  inc()
  a
  ```

- What happens if you try to use `a = 20` after declaring `var a = 10` in Pyret? Why?

- Given this Python code, predict what will print and explain why:

  ```python
  def compare_lists(lst1, lst2):
      return lst1 == lst2
  print(compare_lists([1, 2], [1, 2]))
  print(compare_lists([1, 2], [2, 1]))
  ```

## Wrap-up (5 mins)

- Pyret and Python handle assignment, mutability, and scoping differently.
- Understanding these differences helps avoid bugs and write clearer code.
