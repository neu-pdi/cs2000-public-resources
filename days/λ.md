---
title: Day Î»
---

For today, we are going back to foundations -- some of the oldest, and most fundamental and fascinating ideas in the entire field of computer science.

To get there, we have to talk about a few people. 

The first, you may have heard of, Alan Turing. Turing was a mathematician and logician by training, and like many logicians around that time -- in the 1930s -- he was fascinated by the problem of how you expressed reasoning in mechanical ways. Now, remember -- there were no computers, so this was entirely on paper, on chalkboards, or described from person to person, but it was these people that enabled the breakthroughs that allowed computers to be built. 

Turing did many things -- he's famous for at least three that are worth mentioning --
1. From the very beginning, he was fascinated by the idea of thinking machines. He devised a test for whether a machine was intelligent. 
2. During WWII, he helped figure out how to leverage machines (essentially, pre-computers) to crack what was previously unbreakable Nazi encryption.
3. Relevant to today, he established fundamental results related to what can be expressed by a computer program. 

A fascinating example of the last, Turing proved what is now known as the Halting Problem, which was one of the first impossibility results. What it says, essentially, is that it is impossible to construct a program that, given another program as input, can determine whether it will run forever. What was so interested about that (and it parallels work by logician Kurt Godel with other impossibility results) is that even while he and others were establishing the immense generality of this new idea of computation, they already were figuring out that there were fundamental limits. There were programs that were impossible to write. Not, difficult, or, they didn't know how to write, but mathematically impossible, with proof. 

Computation is, indeed, deep. From the same era -- 1937, mathematician Lothar Collatz presented this seemingly simple problem:

Does the following program run forever on ay integer, or does it terminate for all?

```pyret
fun collatz(n :: Number) -> Number:
  if n <= 1:
    n
  else if num-modulo(n,2) == 0:
    collatz(n / 2)
  else:
    collatz((n * 3) + 1)
  end
end
```

It's a simple program. You could have written it by the first week of class. And yet, we are 88 years later and we still don't know. 

Part of what Turing did was create a universal model of computation, which is now called the Turing machine, which is a idealized model of a machine (it cannot be constructed in reality) that is capable of expressing any program that can be expressed on any machine. 

But, perhaps even more fascinating, that era involved many different universal models of computation, and one of Turings other results was showing that his Turing machine was equivalent to another -- the Lambda Calculus of his PhD advisor, Alonzo Church. 

The lambda calculus, unlike a Turing machine, can and has been used in computation -- indeed, most languages can express it. It involves three things, all of which you have used in Pyret:

- lambda (anonymous functions)
- variables (necessary for lambda, really)
- function application (to use the lambdas)

And that's it. What Church and Turing showed was that with these three things, and _nothing_ else, any program could be expressed. 
    
Now, if you pause and reflect a little, this probably seems impossible. Don't we need numbers, and strings, and booleans, and conditions, and adding, and for loops, and **recursion**, and any number of other things that you've learned this semester? 

The goal of today, and next class, is to show you that you don't. This is a fascinating and fundamental result, and demonstrates the power and flexibility of computation.

Let's begin. 

### Booleans

While we started class with numbers, booleans are simpler data, so we begin our exploration of the lambda calculus with booleans. 

We want to be able to write programs like:

```pyret
true

true and false

if true:
  true
else:
  false
end

if true or false:
  false
else: 
  true
end
```

In order to do that, we need a way of expressing, using just our three tools, `true`, `false`, `and`, `or`, `not`, and `if`.

If we focus on `true` and `false`, these are _values_. i.e., they don't evaluate. Our only _value_ in the lambda calculus is... lambda. So it must be that:

```pyret
true = lam(...): ... end
false = lam(...): ... end
```

Clearly, these should be _different_ (true is not false). 

If we pause on that or a second, and think about `if`, or specifically, that we want to be able to express:

```pyret
if COND:
  THEN
else:
  ELSE
end
```
Where `COND`, `THEN`, and `ELSE` are expressions -- `COND` should be a boolean, `THEN` and `ELSE` don't need to be. What `if` is doing, fundamentally, is using `COND` to decide whether to evaluate to `THEN` or to `ELSE`. How can we possibly express this _decision_ when all we have are lambdas, variables, and function application? 

The answer to both of these questions ends up being the same. If a boolean is a function of _two_ arguments that returns only _one_ of them, depending on whether it is `true` or `false`, then `if` can work by _applying_ the boolean it gets. 

Let's make this concrete:

```pyret
true = lam(x y): x end
false = lam(x y): y end

if COND: THEN else: ELSE end = COND(THEN, ELSE)
```

If we apply this to a concrete example, like one of the ones we wanted to be able to express:

```pyret
if true:
  true
else:
  false
end
```

We can translate that to our lambda calculus representation as:

```pyret
(lam(x, y): x end)(lam(x, y): x end, lam(x, y): y end)
```

And if we _run_ this, then we apply the first `lam`, substituting the two arguments for `x` and `y`. The latter isn't used at all in the body, and so the program evaluates to:

```pyret
lam(x,y): x end
```

Which is our representation of `true` -- exactly as desired.

One issue with testing this -- while we can, on paper, evaluate function application, if we use Pyret to do it, we run into an issue -- functions are not printed out in the interactions window, so we can't see what the end result is. 

One way around this is to add a little bit of code to convert _back_ to ordinary Pyret booleans from what we can now call **Church Booleans**. 

```pyret
fun tobool(cb):
  cb(true, false)
end
```

If we call `tobool(...)` on one of our lambda calculus booleans, we will get back a normal Pyret boolean. This means we can, for example, take our previous example and wrap it appropriately:

```pyret
tobool((lam(x, y): x end)(lam(x, y): x end, lam(x, y): y end))
```
And get back `true` as expected. The other thing we can do to make it easier for us to work with our lambda calculus definitions is define _constants_. Since these can always be substituted, using them isn't changing the fact that we are only using lambda, variable, and applications, but they can make reading
the code a lot easier. 

So we can define:

```pyret
TRUE = lam(x,y): x end
FALSE = lam(x,y): y end
```

This allows us to rewrite our previous example as:

```pyret
tobool(TRUE(TRUE, FALSE))
```

So how do we do `and`, `or`, and `not`? 

Well, each should be a function, `and` and `or` both take two booleans and return one boolean. `not` takes a boolean and returns a boolean. 

So,

```pyret
AND = lam(b1, b2): ... end
```

What should it do? Well, if `b1` is true, then it should return whatever `b2` is. If `b1` is false, it should return false. 

If `b1` is true, we know it is a function that returns its first argument, so in that case, we'd want it to be:

```
AND = lam(b1, b2): b1(b2, ...) end
```

What should the second argument be? Well, if `b1` is true, it doesn't matter. But if `b1` is false, then it will ignore its first argument (so its fine if its `b2`), but it will return whatever its _second_ argument is. What do we want it to return? `false`! So let's make it:

```
AND = lam(b1, b2): b1(b2, FALSE) end
```

`or` is similar -- except now if `b1` is true, we want to return true, and if it is false want to return whatever `b2` is:

```
OR = lam(b1, b2): b1(TRUE, b2) end
```

For `not`, we have a single boolean argument, and if we get true as input, want to return false, and if we get false, want to return true.

How can we do that? Well, we know that true will return its first argument, so:

```
NOT = lam(b): b(FALSE, ...) end
```

And if we get false, then we know it will return its second argument, so we can complete as:


```
NOT = lam(b): b(FALSE, TRUE) end
```
